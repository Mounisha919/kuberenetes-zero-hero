### 🧠 Headless Service in Kubernetes – *Simple & Clear Explanation*

---

#### ✅ **What is a Headless Service?**

A **headless service** is a Kubernetes Service **without a ClusterIP**, allowing **direct access to individual pods** instead of load-balancing between them.

---

#### 📌 **Why Use It?**

* To **discover each pod’s IP individually**
* Needed in **StatefulSets** (e.g., databases like Cassandra, Kafka)
* Enables **peer-to-peer communication**
* Useful when **load balancing is handled by the app**, not K8s

---

### 🔍 Key Point:

A normal service has:

```yaml
spec:
  clusterIP: <auto-assigned IP>
```

A **headless service** has:

```yaml
spec:
  clusterIP: None
```

---

### 🛠️ Example YAML:

```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-headless-service
spec:
  clusterIP: None   # ❗ Marks it as headless
  selector:
    app: myapp
  ports:
    - port: 80
      targetPort: 80
```

---

### 🧪 What Happens Internally?

* Instead of creating a single DNS entry (like `my-headless-service.default.svc.cluster.local → 10.96.0.1`),
* It creates **multiple DNS records**:

```
myapp-0.my-headless-service.default.svc.cluster.local → 10.244.0.10  
myapp-1.my-headless-service.default.svc.cluster.local → 10.244.0.11  
```

> 🎯 This is essential for StatefulSets, where each pod has a **stable identity** and can be accessed by name.

---

### 🆚 Headless vs Normal Service

| Feature        | Normal Service         | Headless Service         |
| -------------- | ---------------------- | ------------------------ |
| ClusterIP      | Yes (default)          | `None`                   |
| DNS record     | One IP for the service | One IP per pod           |
| Load-balancing | Yes                    | No                       |
| Use case       | Web apps, APIs         | Stateful apps, databases |

---

### ✅ Example Use Case

In **StatefulSet**, each pod needs to know the **exact address** of its peers:

```yaml
pod-0 → pod-0.my-headless-service.default.svc.cluster.local  
pod-1 → pod-1.my-headless-service.default.svc.cluster.local
```

---

Here's a complete and easy explanation of **Kubernetes ConfigMaps and Secrets**, including ✅ when to use, 🛠 how to create, and 🔐 security differences.

---

## 📘 CONFIGMAPS vs SECRETS – Full Comparison

| Feature         | ConfigMap                                               | Secret                                              |
| --------------- | ------------------------------------------------------- | --------------------------------------------------- |
| 💡 Purpose      | Store **non-sensitive** config (env vars, app settings) | Store **sensitive** data (passwords, tokens, certs) |
| 🔒 Encrypted    | ❌ No (stored in plain text)                             | ✅ Yes (base64 encoded, can be encrypted at rest)    |
| 📦 Data Type    | Key-value pairs (text)                                  | Key-value pairs (base64)                            |
| 📁 File Support | ✅ Yes (from files, or literals)                         | ✅ Yes                                               |
| 🔁 Volume Mount | ✅ Yes                                                   | ✅ Yes                                               |
| 💬 Env Support  | ✅ Yes                                                   | ✅ Yes                                               |

---

## ✅ WHEN TO USE

| Use Case                | Use This  |
| ----------------------- | --------- |
| App config (host, port) | ConfigMap |
| DB password, API keys   | Secret    |
| TLS certs, SSH keys     | Secret    |
| Toggle feature flags    | ConfigMap |

---

## 🛠 HOW TO CREATE

### 🔹 ConfigMap

```bash
kubectl create configmap my-config --from-literal=APP_PORT=8080 --from-literal=APP_MODE=prod
```

Or from file:

```bash
kubectl create configmap my-config --from-file=config.properties
```

**View:**

```bash
kubectl get configmap my-config -o yaml
```

---

### 🔹 Secret

```bash
kubectl create secret generic my-secret --from-literal=DB_USER=admin --from-literal=DB_PASS='Pa$$w0rd'
```

Or from file:

```bash
kubectl create secret generic my-secret --from-file=ssh-key=~/.ssh/id_rsa
```

**View (base64):**

```bash
kubectl get secret my-secret -o yaml
```

Decode:

```bash
echo 'UGFzc3dvcmQ=' | base64 -d
```

---

## 🔗 USE IN PODS

### 📥 As Environment Variables

```yaml
env:
- name: APP_MODE
  valueFrom:
    configMapKeyRef:
      name: my-config
      key: APP_MODE

- name: DB_PASS
  valueFrom:
    secretKeyRef:
      name: my-secret
      key: DB_PASS
```

---

### 📂 As Volumes

```yaml
volumes:
  - name: config-vol
    configMap:
      name: my-config
  - name: secret-vol
    secret:
      secretName: my-secret

volumeMounts:
  - name: config-vol
    mountPath: /etc/config

  - name: secret-vol
    mountPath: /etc/secret
    readOnly: true
```

---

## 🔐 SECURITY NOTES

* Secrets are **not encrypted by default** — just base64. You must enable encryption at rest in your cluster.
* Use **RBAC** to restrict access to `Secrets`.
* Avoid checking secrets into Git repos!

---

## 🧪 TIP

Want to edit values?

```bash
kubectl edit configmap my-config
kubectl edit secret my-secret
```

---
Here is a **complete, beginner-friendly explanation of Kubernetes Resource Quotas**, covering every concept, example, and use case. ✅ Nothing skipped.

---

# 📘 Kubernetes Resource Quota — COMPLETE GUIDE

---

## 🔍 What is a ResourceQuota?

A **ResourceQuota** in Kubernetes is used to **limit resource usage per namespace**.

Just like budget limits in a department, ResourceQuotas define:

* How much **CPU, memory, storage**, etc. can be used
* How many **Pods, Services, PVCs**, etc. can be created

> 🎯 **Purpose**: Prevent one team/user/app from using all the cluster’s resources.

---

## 💡 Why use ResourceQuota?

| Reason                          | Benefit                    |
| ------------------------------- | -------------------------- |
| Shared clusters (multi-tenant)  | Fair usage control         |
| Prevent DoS (Denial of Service) | Avoid resource starvation  |
| Enforce cost/budget limits      | Control over cloud billing |
| Set dev/test limits separately  | Safe experimentation       |

---

## 🧱 Components of Resource Quota

You usually combine these two:

### 1️⃣ ResourceQuota

Defines the **total allowed resource usage** in the namespace.

### 2️⃣ LimitRange (optional but recommended)

Defines **default** and **maximum per pod/container limits**.

---

## 🧾 What can ResourceQuota limit?

### 💻 Compute Resources:

| Resource          | Description                      |
| ----------------- | -------------------------------- |
| `requests.cpu`    | Total requested CPU cores        |
| `limits.cpu`      | Total CPU usage limit allowed    |
| `requests.memory` | Memory requested across all pods |
| `limits.memory`   | Max memory limit across pods     |

### 🧱 Object Counts:

| Resource                 | Description             |
| ------------------------ | ----------------------- |
| `pods`                   | Total pods in namespace |
| `services`               | Max Services allowed    |
| `replicationcontrollers` | Max RCs allowed         |
| `secrets`                | Max Secrets allowed     |
| `configmaps`             | Max ConfigMaps allowed  |
| `persistentvolumeclaims` | Max PVCs in namespace   |

### 📦 Storage:

| Resource                          | Description                     |
| --------------------------------- | ------------------------------- |
| `requests.storage`                | Total storage requested by PVCs |
| `requests.<storageclass>.storage` | Class-specific limits           |

---

## 📄 EXAMPLE: ResourceQuota YAML

```yaml
apiVersion: v1
kind: ResourceQuota
metadata:
  name: dev-quota
  namespace: dev
spec:
  hard:
    requests.cpu: "2"                # Max total CPU requested
    limits.cpu: "4"                  # Max CPU limit across pods
    requests.memory: "4Gi"           # Total memory requests allowed
    limits.memory: "8Gi"             # Total memory limits allowed
    pods: "10"                       # Max number of pods
    configmaps: "5"                  # Max ConfigMaps
    secrets: "10"                    # Max Secrets
    persistentvolumeclaims: "5"     # Max PVCs
```

---

## 🔄 APPLY RESOURCEQUOTA

```bash
kubectl apply -f dev-quota.yaml
```

Check the quota status:

```bash
kubectl get resourcequota -n dev
kubectl describe resourcequota dev-quota -n dev
```

---

## 🧷 LimitRange Example (Optional but Best Practice)

Sets **default resource requests/limits** for containers that don’t specify them.

```yaml
apiVersion: v1
kind: LimitRange
metadata:
  name: default-limits
  namespace: dev
spec:
  limits:
  - default:
      cpu: 500m
      memory: 512Mi
    defaultRequest:
      cpu: 200m
      memory: 256Mi
    type: Container
```

✅ This ensures every pod gets reasonable limits even if the developer forgets to set them.

---

## 🔐 IMPORTANT RULES

| Rule                                                                            | Description |
| ------------------------------------------------------------------------------- | ----------- |
| 🚫 No pod can be created **without specifying resources** once quota is active. |             |
| ⛔ If a request would **exceed quota**, the API server will reject it.           |             |
| 🧮 Kubernetes will **track usage automatically** (no manual tracking needed).   |             |

---

## ⚙️ ResourceQuota with StorageClass

To limit PVC usage **per storage class**:

```yaml
spec:
  hard:
    requests.storage: "20Gi"
    persistentvolumeclaims: "3"
    requests.standard.storage: "10Gi"
    requests.fast-ssd.storage: "10Gi"
```

---

## 📊 View Usage

```bash
kubectl describe quota dev-quota -n dev
```

You’ll see:

```
Resource                    Used  Hard
--------                    ----  ----
pods                        2     10
requests.cpu                1     2
limits.cpu                  1.5   4
requests.memory             2Gi   4Gi
limits.memory               3Gi   8Gi
```

---

## 🔁 Real-time Example

### Scenario:

Your **dev** team shares a namespace `dev`. To prevent them from deploying 100 pods using 32 CPUs and 64GB RAM, you define:

* Max 10 Pods
* Total memory max 8Gi
* Total CPU max 4 cores

So even if someone tries:

```yaml
resources:
  requests:
    cpu: 2
    memory: 6Gi
```

For **5 pods**, it will be rejected (6Gi \* 5 = 30Gi > 8Gi quota).

---

## ✅ Summary Points (Highlight):

* 🔒 **ResourceQuota = Namespace-level resource limits**
* 🎛️ Controls both **compute** and **object counts**
* 🛑 Prevents resource abuse
* ⚠️ Once active, **pods must declare requests/limits**
* 🔧 Combine with **LimitRange** for automatic per-pod defaults

---

Here is a **complete and easy-to-understand explanation of ResourceQuota in Kubernetes** — no topic skipped:

---

# 📦 Kubernetes `ResourceQuota` — Complete Explanation

## ✅ What is `ResourceQuota`?

`ResourceQuota` is a Kubernetes object used to **limit resource consumption** (like CPU, memory, storage, object count, etc.) **per namespace**. It ensures fair usage among teams or applications sharing the same cluster.

---

## 🧠 Why Use Resource Quotas?

* Prevent a single user or app from consuming all cluster resources.
* Enforce limits on:

  * CPU, memory, ephemeral storage
  * Number of pods, services, PVCs, etc.
  * Number of secrets, configmaps, etc.
* Maintain multi-tenant isolation and predictability.

---

## 🔖 Where is ResourceQuota Applied?

* At the **namespace level only**.
* All limits apply to the **total usage of all resources** in the namespace.

---

## ⚙️ Types of Quotas You Can Set

| Resource Type              | What It Controls                              |
| -------------------------- | --------------------------------------------- |
| `cpu`, `memory`            | Total compute usage of all pods/containers    |
| `requests.cpu`             | Total CPU requested across all pods           |
| `limits.memory`            | Total memory limits set across all containers |
| `pods`                     | Maximum number of pods allowed                |
| `services`                 | Number of services allowed                    |
| `persistentvolumeclaims`   | PVCs allowed in the namespace                 |
| `secrets`, `configmaps`    | Total secrets or configmaps allowed           |
| `count/<resource>`         | Set count on any specific resource (advanced) |
| `requests.storage`         | Storage requests (PVCs)                       |
| `limits.ephemeral-storage` | Ephemeral storage limits                      |

---

## 🧾 Example: ResourceQuota YAML

```yaml
apiVersion: v1
kind: ResourceQuota
metadata:
  name: dev-quota
  namespace: dev
spec:
  hard:
    requests.cpu: "2"
    requests.memory: "4Gi"
    limits.cpu: "4"
    limits.memory: "8Gi"
    pods: "10"
    services: "5"
    persistentvolumeclaims: "4"
    configmaps: "20"
    secrets: "10"
```

---

## 📌 Important Notes

1. **Multiple Quotas**: You can define multiple ResourceQuotas per namespace, but each must limit different resource types (to avoid conflicts).
2. **Enforcement**: K8s blocks new pods or objects once a quota is exceeded.
3. **Quota applies to Requests + Limits**: Both `requests` and `limits` must be considered.
4. **Must use LimitRange**: If a pod doesn’t specify resource requests/limits, ResourceQuota won’t apply unless a `LimitRange` provides default values.
5. **Ephemeral Resources**: You can control short-term resources like logs or temp files using `ephemeral-storage`.

---

## 🔎 View Current Usage vs Quota

```bash
kubectl describe quota dev-quota -n dev
```

Or:

```bash
kubectl get resourcequota -n dev
```

---

## 🔄 How ResourceQuota Works (Step-by-Step)

1. **Admin creates a ResourceQuota** in a namespace.
2. Users deploy pods/services in that namespace.
3. K8s checks if requested resources fit within the quota.
4. If not, the object creation fails with a `quota exceeded` error.

---

## ✅ Good Practice

* Pair ResourceQuota with **LimitRange** for maximum control.
* Monitor quotas using tools like Prometheus or Grafana.
* Define **different quotas for dev, test, prod** environments.

---

## 🧪 Example Error if Quota Exceeded

```
Error from server (Forbidden): error when creating "pod.yaml": 
pods "nginx" is forbidden: exceeded quota: dev-quota, 
requested: pods=1, used: pods=10, limited: pods=10
```

---

## 🔐 Quota + Security

While `ResourceQuota` doesn’t enforce security directly, limiting resources indirectly:

* Prevents DoS attacks by rogue containers
* Ensures predictable cost usage in cloud environments

---

## 📘 Advanced Topics (Optional Reading)

* **Quota Scopes**: You can apply quotas only to pods with certain characteristics using `scopes` like:

  * `BestEffort`: Only applies to pods with no resource limits
  * `NotBestEffort`: Pods with any limit set
  * `Terminating`: For pods that have `activeDeadlineSeconds` (short-lived)
  * `NotTerminating`: Long-running pods

```yaml
spec:
  scopes:
    - NotBestEffort
```

---

## 🧠 Summary

| Feature                 | ResourceQuota                 |
| ----------------------- | ----------------------------- |
| Level                   | Namespace                     |
| Controls                | CPU, memory, pods, PVCs, etc. |
| Enforced Automatically? | ✅ Yes                         |
| Default behavior        | Not enforced unless defined   |
| Pair with               | LimitRange                    |

---
Absolutely! Here's a **complete explanation of Kubernetes Resource Quotas** — including **Scopes** like `BestEffort`, `Terminating`, and **Object Count Quotas** — with examples and **no important concept missed**:

---

## 📘 Kubernetes Resource Quota — Full Explanation

A **ResourceQuota** is a Kubernetes object that limits the aggregate resource consumption (like CPU, memory, object count) per namespace. It helps in **multi-tenant environments** to prevent a single team from over-consuming resources.

---

### ✅ Why Use ResourceQuota?

* Control how many resources (Pods, Services, PVCs) a namespace can use.
* Avoid overuse by one user/team in shared clusters.
* Enforce fair sharing and limits across multiple namespaces.

---

## 🔹 Key Concepts

| Concept         | Explanation                                                   |
| --------------- | ------------------------------------------------------------- |
| **Namespace**   | ResourceQuota applies to a **single namespace**.              |
| **Hard Limits** | Defines upper limits on resources or object count.            |
| **Scopes**      | Filters which resources the quota applies to.                 |
| **LimitRange**  | Works with ResourceQuota to define min/max per pod/container. |

---

## 🧱 Resource Types That Can Be Limited

| Resource Type | Example Key                        |
| ------------- | ---------------------------------- |
| CPU           | `limits.cpu`, `requests.cpu`       |
| Memory        | `limits.memory`, `requests.memory` |
| Pods          | `pods`                             |
| Services      | `services`                         |
| PVCs          | `persistentvolumeclaims`           |
| Secrets       | `secrets`                          |
| ConfigMaps    | `configmaps`                       |
| LoadBalancers | `services.loadbalancers`           |
| Object counts | Number of each resource type       |

---

## 📌 Example: CPU/Memory + Object Count Quota

```yaml
apiVersion: v1
kind: ResourceQuota
metadata:
  name: example-quota
  namespace: dev
spec:
  hard:
    pods: "10"
    requests.cpu: "4"
    requests.memory: "8Gi"
    limits.cpu: "8"
    limits.memory: "16Gi"
    persistentvolumeclaims: "5"
    services: "10"
    configmaps: "20"
    secrets: "10"
```

---

## 🔍 Scopes in ResourceQuota

Scopes **filter which pods/resources the quota applies to**.

| Scope Name       | Description                                                                     |
| ---------------- | ------------------------------------------------------------------------------- |
| `BestEffort`     | Applies only to Pods with QoS class `BestEffort` (no resource requests/limits). |
| `NotBestEffort`  | Applies to Pods that are not BestEffort.                                        |
| `Terminating`    | Applies only to Pods with `activeDeadlineSeconds` set (i.e., short-lived jobs). |
| `NotTerminating` | Pods without `activeDeadlineSeconds`.                                           |
| `PriorityClass`  | Targets pods with a specific priority class.                                    |

---

### 📌 Example: BestEffort Scope

```yaml
apiVersion: v1
kind: ResourceQuota
metadata:
  name: besteffort-quota
  namespace: dev
spec:
  hard:
    pods: "5"
  scopes:
    - BestEffort
```

> 🔎 **Explanation**: This quota applies **only to BestEffort pods** (no CPU/memory requests/limits defined).

---

## 🧠 Quality of Service (QoS) and Scopes

| QoS Class    | How It's Determined             | Affected by Scopes |
| ------------ | ------------------------------- | ------------------ |
| `BestEffort` | No requests or limits defined   | ✅ `BestEffort`     |
| `Burstable`  | Requests < Limits               | ✅ `NotBestEffort`  |
| `Guaranteed` | Requests = Limits (set for all) | ✅ `NotBestEffort`  |

---

## 🎯 PriorityClass Scope Example

```yaml
apiVersion: v1
kind: ResourceQuota
metadata:
  name: high-priority-quota
  namespace: dev
spec:
  hard:
    pods: "10"
  scopeSelector:
    matchExpressions:
      - scopeName: PriorityClass
        operator: In
        values: ["high-priority"]
```

> 🎯 This applies quota only to pods with `priorityClassName: high-priority`.

---

## 📈 Object Count Quotas

You can limit the **number of objects** (like Pods, PVCs, ConfigMaps, Secrets, Services, etc.).

| Resource Type | Quota Key                |
| ------------- | ------------------------ |
| Pods          | `pods`                   |
| Services      | `services`               |
| Secrets       | `secrets`                |
| ConfigMaps    | `configmaps`             |
| PVCs          | `persistentvolumeclaims` |
| LoadBalancers | `services.loadbalancers` |

📌 **Example**:

```yaml
hard:
  configmaps: "10"
  secrets: "5"
  persistentvolumeclaims: "3"
```

---

## 🧪 How to View Quota Usage

```bash
kubectl get resourcequota --namespace=dev
kubectl describe quota example-quota -n dev
```

---

## 💡 When ResourceQuota is Applied?

* When you create/update a resource (Pod, PVC, etc.), Kubernetes **validates** against the quota before allowing it.
* If the resource **exceeds the quota**, it will **fail to schedule/create**.

---

## 🛠️ Combine with LimitRange

To prevent large pods inside quota limits:

```yaml
apiVersion: v1
kind: LimitRange
metadata:
  name: limits
  namespace: dev
spec:
  limits:
  - default:
      cpu: 500m
      memory: 512Mi
    defaultRequest:
      cpu: 250m
      memory: 256Mi
    type: Container
```

---

## ✅ Summary

| Feature               | Description                                  |
| --------------------- | -------------------------------------------- |
| `ResourceQuota`       | Limits total resources (per namespace)       |
| `LimitRange`          | Sets per-pod/container defaults/limits       |
| `Scopes`              | Apply quota to specific pod types            |
| `Object Count Quota`  | Limits number of objects like PVCs, Services |
| `BestEffort` Scope    | Controls pods with **no limits**             |
| `Terminating` Scope   | Controls short-lived pods (e.g., jobs)       |
| `PriorityClass` Scope | Controls based on `priorityClassName`        |

---

Let me know if you want **YAML templates** or a **visual summary/cheat sheet** for this!
Here’s a **complete and easy explanation of Probes in Kubernetes**, including types, examples, and best practices:

---

## 🔍 **Kubernetes Probes – Complete Explanation**

### 🧠 What is a Probe?

A **probe** in Kubernetes is a mechanism used by the **Kubelet** to **check the health and status** of a container inside a pod.

There are **3 types of probes**:

1. ✅ **Liveness Probe**
2. ⏳ **Readiness Probe**
3. 🚥 **Startup Probe** (since v1.16+)

---

## ✅ 1. **Liveness Probe**

* Checks **if the container is alive**.
* If it fails → Kubernetes **restarts the container**.
* Use it when the app might get stuck or crash.

### 🧪 Example:

```yaml
livenessProbe:
  httpGet:
    path: /healthz
    port: 8080
  initialDelaySeconds: 5
  periodSeconds: 10
```

📌 **When to use**: If your app might crash or hang and you want K8s to auto-recover.

---

## ⏳ 2. **Readiness Probe**

* Checks **if the container is ready to serve traffic**.
* If it fails → Kubernetes **removes the pod from service endpoints** (no traffic is sent to it).
* Does **not restart** the container.

### 🧪 Example:

```yaml
readinessProbe:
  httpGet:
    path: /ready
    port: 8080
  initialDelaySeconds: 5
  periodSeconds: 10
```

📌 **When to use**: If app needs time to load (e.g., DB connection, cache warmup) before receiving traffic.

---

## 🚥 3. **Startup Probe**

* Checks **if the app has started successfully**.
* If it fails → **container is killed and restarted**.
* It **disables liveness and readiness probes** until success.

### 🧪 Example:

```yaml
startupProbe:
  httpGet:
    path: /startup
    port: 8080
  failureThreshold: 30
  periodSeconds: 10
```

📌 **When to use**: If your app has a slow start and you don’t want K8s to kill it prematurely.

---

## 🛠️ Probe Types (Execution Methods)

You can define probes using one of the following:

| Type        | How it works                                      |
| ----------- | ------------------------------------------------- |
| `httpGet`   | Makes an HTTP GET request to a container endpoint |
| `tcpSocket` | Opens a TCP connection to the container           |
| `exec`      | Runs a command inside the container               |

### Examples:

**HTTP GET:**

```yaml
httpGet:
  path: /health
  port: 8080
```

**TCP Socket:**

```yaml
tcpSocket:
  port: 3306
```

**Exec:**

```yaml
exec:
  command:
    - cat
    - /tmp/healthy
```

---

## ⏲️ Common Probe Fields

| Field                 | Description                                            |
| --------------------- | ------------------------------------------------------ |
| `initialDelaySeconds` | Wait time before starting probe after container starts |
| `periodSeconds`       | Frequency of probe checks                              |
| `timeoutSeconds`      | Max time to wait for probe response                    |
| `failureThreshold`    | How many failures before marking as failed             |
| `successThreshold`    | How many successes before marking as healthy           |

---

## ✅ Best Practices

* Use **liveness** to auto-recover stuck containers.
* Use **readiness** to avoid sending traffic to unready pods.
* Use **startup** for slow booting apps.
* Keep probe endpoints lightweight.
* Avoid setting overly aggressive probe timings.

---

## 📊 Summary Table

| Probe Type | Purpose                         | Effect of Failure        |
| ---------- | ------------------------------- | ------------------------ |
| Liveness   | Checks if app is alive          | Pod is restarted         |
| Readiness  | Checks if app can serve traffic | Pod removed from service |
| Startup    | Checks if app has booted        | Pod restarted (once)     |

---

Let me know if you want a sample YAML manifest with all 3 probes together!
Here’s a **sample Kubernetes pod YAML manifest** with **Liveness**, **Readiness**, and **Startup Probes** implemented together in a clean and simple way:

---

## ✅ Sample YAML Manifest with All 3 Probes

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: demo-app
spec:
  containers:
  - name: myapp-container
    image: myapp:latest
    ports:
    - containerPort: 8080

    # 🚥 Startup Probe (Runs first)
    startupProbe:
      httpGet:
        path: /startup
        port: 8080
      failureThreshold: 30
      periodSeconds: 10
      initialDelaySeconds: 5
      timeoutSeconds: 2

    # ✅ Liveness Probe (Enabled after Startup Probe passes)
    livenessProbe:
      httpGet:
        path: /healthz
        port: 8080
      initialDelaySeconds: 15
      periodSeconds: 10
      failureThreshold: 3
      timeoutSeconds: 2

    # ⏳ Readiness Probe (Determines if ready to serve traffic)
    readinessProbe:
      httpGet:
        path: /ready
        port: 8080
      initialDelaySeconds: 10
      periodSeconds: 5
      failureThreshold: 3
      successThreshold: 1
      timeoutSeconds: 2
```

---

### 🔍 What Happens in Order:

1. **Startup Probe** checks `/startup` endpoint.

   * If it fails 30 times (i.e., for \~5 minutes), pod is killed.
   * If it passes → then only liveness and readiness begin.

2. **Liveness Probe** keeps checking `/healthz` every 10 seconds.

   * If it fails 3 times → container restarts.

3. **Readiness Probe** checks `/ready` every 5 seconds.

   * If it fails → pod is removed from service (no traffic sent).

---

Let me know if you want the same example using `exec` or `tcpSocket` probes instead of HTTP!
Absolutely! Let's now walk through **Kubernetes Probes using `exec`, `httpGet`, and `tcpSocket`**, with **examples** and **clear explanations** for:

* 🔍 **Liveness Probe** – checks if the container should be restarted
* 🟢 **Readiness Probe** – checks if the container is ready to receive traffic
* 🚀 **Startup Probe** – delays liveness/readiness until the app has started

---

## 🧠 Types of Probes in Kubernetes

| Type             | Purpose                                 | What happens if it fails?                 |
| ---------------- | --------------------------------------- | ----------------------------------------- |
| `livenessProbe`  | Checks if the container is alive        | Container is **restarted**                |
| `readinessProbe` | Checks if the app is ready to serve     | Pod is **removed from Service endpoints** |
| `startupProbe`   | Checks if the app has finished starting | If it fails, **container is killed**      |

---

## ✅ Probe Types Based on Method

Kubernetes supports 3 ways to probe containers:

| Method      | Description                              |
| ----------- | ---------------------------------------- |
| `httpGet`   | Makes an HTTP request to a path/port     |
| `exec`      | Runs a command inside the container      |
| `tcpSocket` | Tries to open a TCP connection to a port |

---

## 1️⃣ Probes with `exec`

Executes a command inside the container and checks **exit status**:

* **0** = success
* **non-zero** = failure

### ✅ Example:

```yaml
livenessProbe:
  exec:
    command:
    - cat
    - /tmp/healthy
  initialDelaySeconds: 5
  periodSeconds: 10
```

➡️ This probe runs `cat /tmp/healthy` inside the container.
If the file doesn’t exist, the probe fails and container restarts.

---

## 2️⃣ Probes with `tcpSocket`

Checks whether the container is **listening** on a port using TCP.

### ✅ Example:

```yaml
readinessProbe:
  tcpSocket:
    port: 8080
  initialDelaySeconds: 10
  periodSeconds: 5
```

➡️ Kubernetes attempts to open a TCP connection to `localhost:8080`.
If successful → container is considered ready.

Useful for non-HTTP apps like Redis, PostgreSQL, etc.

---

## 3️⃣ Probes with `httpGet`

Makes an HTTP GET request to a container's port/path.

### ✅ Example:

```yaml
startupProbe:
  httpGet:
    path: /startup
    port: 8080
  failureThreshold: 30
  periodSeconds: 10
  initialDelaySeconds: 5
```

➡️ This waits up to **5 mins** (30 × 10s) for app to become ready.

---

## 🧩 Full Example With All Types

Here’s a **combined example** using all types of probes:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: probe-demo
spec:
  containers:
  - name: app
    image: myapp:latest
    ports:
    - containerPort: 8080

    # 🧪 Startup Probe with HTTP
    startupProbe:
      httpGet:
        path: /startup
        port: 8080
      failureThreshold: 30
      periodSeconds: 10

    # 🔁 Liveness Probe with exec
    livenessProbe:
      exec:
        command:
        - cat
        - /tmp/healthy
      initialDelaySeconds: 15
      periodSeconds: 20

    # ✅ Readiness Probe with TCP
    readinessProbe:
      tcpSocket:
        port: 8080
      initialDelaySeconds: 5
      periodSeconds: 5
```

---

## 📝 Key Points to Remember

* `startupProbe` blocks liveness and readiness until app is fully started.
* `livenessProbe` restarts container if it fails.
* `readinessProbe` removes pod from Service load balancing if it fails.
* Use `exec` for internal logic, `tcpSocket` for TCP apps, and `httpGet` for web apps.

---

Would you like me to show:

* 💡 Tips for debugging failing probes?
* 🧪 A real-world example for a specific app like Node.js, Python, or Nginx?

Let me know!
